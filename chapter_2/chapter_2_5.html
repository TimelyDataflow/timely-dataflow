<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A Worked Example</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../introduction.html">Timely Dataflow</a></li><li class="chapter-item expanded "><a href="../chapter_0/chapter_0.html"><strong aria-hidden="true">1.</strong> Motivation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_0/chapter_0_0.html"><strong aria-hidden="true">1.1.</strong> A Simplest Example</a></li><li class="chapter-item expanded "><a href="../chapter_0/chapter_0_1.html"><strong aria-hidden="true">1.2.</strong> A Simple Example</a></li><li class="chapter-item expanded "><a href="../chapter_0/chapter_0_2.html"><strong aria-hidden="true">1.3.</strong> When to use Timely Dataflow</a></li><li class="chapter-item expanded "><a href="../chapter_0/chapter_0_3.html"><strong aria-hidden="true">1.4.</strong> When not to use Timely Dataflow</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_1/chapter_1.html"><strong aria-hidden="true">2.</strong> Core Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_1/chapter_1_1.html"><strong aria-hidden="true">2.1.</strong> Dataflow</a></li><li class="chapter-item expanded "><a href="../chapter_1/chapter_1_2.html"><strong aria-hidden="true">2.2.</strong> Timestamps</a></li><li class="chapter-item expanded "><a href="../chapter_1/chapter_1_3.html"><strong aria-hidden="true">2.3.</strong> Progress</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_2/chapter_2.html"><strong aria-hidden="true">3.</strong> Building Timely Dataflows</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_2/chapter_2_1.html"><strong aria-hidden="true">3.1.</strong> Creating Inputs</a></li><li class="chapter-item expanded "><a href="../chapter_2/chapter_2_2.html"><strong aria-hidden="true">3.2.</strong> Observing Outputs</a></li><li class="chapter-item expanded "><a href="../chapter_2/chapter_2_3.html"><strong aria-hidden="true">3.3.</strong> Adding Operators</a></li><li class="chapter-item expanded "><a href="../chapter_2/chapter_2_4.html"><strong aria-hidden="true">3.4.</strong> Creating Operators</a></li><li class="chapter-item expanded "><a href="../chapter_2/chapter_2_5.html" class="active"><strong aria-hidden="true">3.5.</strong> A Worked Example</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_3/chapter_3.html"><strong aria-hidden="true">4.</strong> Running Timely Dataflows</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_3/chapter_3_1.html"><strong aria-hidden="true">4.1.</strong> Providing Input</a></li><li class="chapter-item expanded "><a href="../chapter_3/chapter_3_2.html"><strong aria-hidden="true">4.2.</strong> Monitoring Probes</a></li><li class="chapter-item expanded "><a href="../chapter_3/chapter_3_3.html"><strong aria-hidden="true">4.3.</strong> Operator Execution</a></li><li class="chapter-item expanded "><a href="../chapter_3/chapter_3_4.html"><strong aria-hidden="true">4.4.</strong> Extending Dataflows</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_4/chapter_4.html"><strong aria-hidden="true">5.</strong> Advanced Timely Dataflow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_4/chapter_4_1.html"><strong aria-hidden="true">5.1.</strong> Scopes</a></li><li class="chapter-item expanded "><a href="../chapter_4/chapter_4_2.html"><strong aria-hidden="true">5.2.</strong> Iteration</a></li><li class="chapter-item expanded "><a href="../chapter_4/chapter_4_3.html"><strong aria-hidden="true">5.3.</strong> Flow Control</a></li><li class="chapter-item expanded "><a href="../chapter_4/chapter_4_4.html"><strong aria-hidden="true">5.4.</strong> Capture and Replay</a></li><li class="chapter-item expanded "><a href="../chapter_4/chapter_4_5.html"><strong aria-hidden="true">5.5.</strong> Custom Datatypes</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_5/chapter_5.html"><strong aria-hidden="true">6.</strong> Internals</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_5/chapter_5_1.html"><strong aria-hidden="true">6.1.</strong> Communication</a></li><li class="chapter-item expanded "><a href="../chapter_5/chapter_5_2.html"><strong aria-hidden="true">6.2.</strong> Progress Tracking</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="a-worked-example"><a class="header" href="#a-worked-example">A Worked Example</a></h1>
<p>You may have heard of <code>word_count</code> as the archetypical "big data" problem: you have a large collection of text, and what you want most in life is to know how many of each word are present in the text. The data are too large to load into memory, but let's assume that the set of distinct words, each with an associated count, is small enough to fit in memory.</p>
<p>Let's take the <code>word_count</code> example in the streaming direction. For whatever reason, your collection of text <em>changes</em>. As time moves along, some new texts are added and some old texts are retracted. We don't know why this happens, we just get told about the changes. Our new job is to <em>maintain</em> the <code>word_count</code> computation, in the face of arbitrary changes to the collection of texts, as promptly as possible.</p>
<p>Let's model a changing corpus of text as a list of pairs of <em>times</em> which will be <code>u64</code> integers with a list of <em>changes</em> which are each pairs <code>(String, i64)</code> indicating the text and whether it has been added (+1) or removed (-1).</p>
<p>We are going to write a program that is the moral equivalent of the following sequential Rust program:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// From a sequence of changes to the occurrences of text,
/// produce the changing counts of words in that text.
fn word_count(mut history: Vec&lt;(u64, Vec&lt;(String, i64)&gt;)&gt;) {
    let mut counts = ::std::collections::HashMap::new();
    for (time, mut changes) in history.drain(..) {
        for (text, diff) in changes.drain(..) {
            for word in text.split_whitespace() {
                let mut entry = counts.entry(word.to_owned())
                                      .or_insert(0i64);
                *entry += diff;
                println!("seen: {:?}", (word, *entry));
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This program is fairly straightforward; hopefully you understand its intent, even if you aren't familiar with every method and type. However, the program is also very specific about what must happen: we process the history in order, and for each time we process the text changes in order. The program does not allow for any flexibility here.</p>
<p>Our program will be a bit larger, but it will be more flexible. By specifying more about what we want to happen to the data, and less about which order this needs to happen, we will gain the ability to scale out to multiple workers across multiple machines.</p>
<h2 id="starting-out-with-text-streams"><a class="header" href="#starting-out-with-text-streams">Starting out with text streams</a></h2>
<p>Let's first build a timely computation into which we can send text and which will show us the text back. Our next steps will be to put more clever logic in place, but let's start here to get some boiler-plate out of the way.</p>
<pre><pre class="playground"><code class="language-rust">extern crate timely;

use timely::dataflow::{InputHandle, ProbeHandle};
use timely::dataflow::operators::{Inspect, Probe};

fn main() {
    // initializes and runs a timely dataflow.
    timely::execute_from_args(std::env::args(), |worker| {

        // create input and output handles.
        let mut input = InputHandle::new();
        let mut probe = ProbeHandle::new();

        // build a new dataflow.
        worker.dataflow(|scope| {
            input.to_stream(scope)
                 .inspect(|x| println!("seen: {:?}", x))
                 .probe_with(&amp;mut probe);
        });

        // feed the dataflow with data.
        for round in 0..10 {
            input.send(("round".to_owned(), 1));
            input.advance_to(round + 1);
            while probe.less_than(input.time()) {
                worker.step();
            }
        }
    }).unwrap();
}</code></pre></pre>
<p>This example code is pretty close to a minimal non-trivial timely dataflow computation. It explains how participating timely workers (there may be many, remember) should construct and run a timely dataflow computation.</p>
<p>After some boiler-plate including the <code>timely</code> crate and some of its traits and types, we get to work:</p>
<pre><code class="language-rust ignore">        // create input and output handles.
        let mut input = InputHandle::new();
        let mut probe = ProbeHandle::new();</code></pre>
<p>The input handle is how we supply data to the computation, and the probe handle is how we check whether the computation is complete up through certain inputs. Since a streaming computation may never "finish", <code>probe</code> is the only way to understand how much progress we've made.</p>
<p>The next step is to build a timely dataflow. Here we use <code>input</code> as a source of data, and attach <code>probe</code> to the end so that we can watch for completion of work.</p>
<pre><code class="language-rust ignore">        // build a new dataflow.
        worker.dataflow(|scope| {
            input.to_stream(scope)
                 .inspect(|x| println!("seen: {:?}", x))
                 .probe_with(&amp;mut probe);
        });</code></pre>
<p>This computation is pretty simple: it just prints out the inputs we send at it.</p>
<p>Having constructed the dataflow, we feed it some data.</p>
<pre><code class="language-rust ignore">        // feed the dataflow with data.
        for round in 0..10 {
            input.send(("round".to_owned(), 1));
            input.advance_to(round + 1);
            while probe.less_than(input.time()) {
                worker.step();
            }
        }</code></pre>
<p>There are several things going on here. First, we <code>send</code> some data into the input, which allows the data to circulate through the workers along the dataflow. This data will be of type <code>(String, i64)</code>, because our example wants to send some text and annotate each with the change in the count (we add or remove text with <code>+1</code> or <code>-1</code>, respectively). Second, we <code>advance_to</code> to tell timely dataflow that we have ceased sending data for <code>round</code> and anything before it. At this point timely can start to reason about <code>round</code> becoming complete, once all the associated data make their way through the dataflow. Finally, we repeatedly <code>step</code> the worker until <code>probe</code> reports that it has caught up to <code>round + 1</code>, meaning that data for <code>round</code> are fully flushed from the system (and printed to the screen, one hopes).</p>
<h2 id="breaking-text-into-words"><a class="header" href="#breaking-text-into-words">Breaking text into words</a></h2>
<p>Let's add a simple operator that takes our text strings we supply as input and breaks them into words.</p>
<p>More specifically, we will take <code>(String, i64)</code> pairs and break them into many <code>(String, i64)</code> pairs with the same <code>i64</code> value, because if we are adding some text we'll add the words, and if subtracting text we'll subtract the words.</p>
<p>Rather than repeat all the code up above, I'm just going to show you the fragment you insert between <code>to_stream</code> and <code>inspect</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate timely;
</span><span class="boring">
</span><span class="boring">use timely::dataflow::{InputHandle, ProbeHandle};
</span><span class="boring">use timely::dataflow::operators::{Inspect, Probe, Map};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // initializes and runs a timely dataflow.
</span><span class="boring">    timely::execute_from_args(std::env::args(), |worker| {
</span><span class="boring">
</span><span class="boring">        // create input and output handles.
</span><span class="boring">        let mut input = InputHandle::new();
</span><span class="boring">        let mut probe = ProbeHandle::new();
</span><span class="boring">
</span><span class="boring">        // build a new dataflow.
</span><span class="boring">        worker.dataflow(|scope| {
</span><span class="boring">            input.to_stream(scope)
</span>                 .flat_map(|(text, diff): (String, i64)|
                     text.split_whitespace()
                         .map(move |word| (word.to_owned(), diff))
                         .collect::&lt;Vec&lt;_&gt;&gt;()
                 )
<span class="boring">                 .inspect(|x| println!("seen: {:?}", x))
</span><span class="boring">                 .probe_with(&amp;mut probe);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // feed the dataflow with data.
</span><span class="boring">        for round in 0..10 {
</span><span class="boring">            input.send(("round".to_owned(), 1));
</span><span class="boring">            input.advance_to(round + 1);
</span><span class="boring">            while probe.less_than(input.time()) {
</span><span class="boring">                worker.step();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }).unwrap();
</span><span class="boring">}</span></code></pre></pre>
<p>The <code>flat_map</code> method expects to be told how to take each record and turn it into an iterator. Here, we are saying that each received <code>text</code> should be split (at whitespace boundaries), and each resulting <code>word</code> should be paired up with <code>diff</code>. We do a weird <code>collect</code> thing at the end because <code>split_whitespace</code> tries to hand back pointers into <code>text</code> and it makes life complicated. Sorry, blame Rust (and then blame me for using Rust).</p>
<p>This code should now show us the stream of <code>(word, diff)</code> pairs that fly by, but we still haven't done anything complicated with them yet.</p>
<h2 id="maintaining-word-counts"><a class="header" href="#maintaining-word-counts">Maintaining word counts</a></h2>
<p>This gets a bit more interesting. We don't have an operator to maintain word counts, so we are going to write one.</p>
<p>We start with a stream of words and differences coming at us. This stream has no particular structure, and in particular if the stream is distributed across multiple workers we have no assurance that all instances of the same word are at the same worker. This means that if each worker just adds up the counts for each word, we will get a bunch of partial results, local to each worker.</p>
<p>We will need to introduce <em>data exchange</em>, where the workers communicate with each other to shuffle the data so that the resulting distribution provides correct results. Specifically, we are going to distribute the data so that each individual word goes to the same worker, but the words themselves may be distributed across workers.</p>
<p>Having exchanged the data, each worker will need a moment of care when it processes its inputs. Because the data are coming in from multiple workers, they may no longer be in "time order"; some workers may have moved through their inputs faster than others, and may be producing data for the next time while others lag behind. This operator means to produce the word count changes <em>as if processed sequentially</em>, and it will need to delay processing changes that come early.</p>
<p>As before, I'm just going to show you the new code, which now lives just after <code>flat_map</code> and just before <code>inspect</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate timely;
</span><span class="boring">
</span><span class="boring">use timely::dataflow::{InputHandle, ProbeHandle};
</span><span class="boring">use timely::dataflow::operators::{Inspect, Probe, Map};
</span><span class="boring">
</span><span class="boring">use std::collections::HashMap;
</span><span class="boring">use timely::dataflow::channels::pact::Exchange;
</span><span class="boring">use timely::dataflow::operators::Operator;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // initializes and runs a timely dataflow.
</span><span class="boring">    timely::execute_from_args(std::env::args(), |worker| {
</span><span class="boring">
</span><span class="boring">        // create input and output handles.
</span><span class="boring">        let mut input = InputHandle::new();
</span><span class="boring">        let mut probe = ProbeHandle::new();
</span><span class="boring">
</span><span class="boring">        // build a new dataflow.
</span><span class="boring">        worker.dataflow::&lt;usize,_,_&gt;(|scope| {
</span><span class="boring">            input.to_stream(scope)
</span><span class="boring">                .flat_map(|(text, diff): (String, i64)|
</span><span class="boring">                    text.split_whitespace()
</span><span class="boring">                        .map(move |word| (word.to_owned(), diff))
</span><span class="boring">                        .collect::&lt;Vec&lt;_&gt;&gt;()
</span><span class="boring">                )
</span>                .unary_frontier(
                    Exchange::new(|x: &amp;(String, i64)| (x.0).len() as u64),
                    "WordCount",
                    |_capability, operator_info| {

                    // allocate operator-local storage.
                    let mut queues = HashMap::new();
                    let mut counts = HashMap::new();
                    let mut buffer = Vec::new();

                    move |input, output| {

                        // for each input batch, stash it at `time`.
                        while let Some((time, data)) = input.next() {
                            queues.entry(time.retain())
                                  .or_insert(Vec::new())
                                  .extend(std::mem::take(data));
                        }

                        // enable each stashed time if ready.
                        for (time, vals) in queues.iter_mut() {
                            if !input.frontier().less_equal(time.time()) {
                                let vals = std::mem::replace(vals, Vec::new());
                                buffer.push((time.clone(), vals));
                            }
                        }

                        // drop complete time and allocations.
                        queues.retain(|time, vals| vals.len() &gt; 0);

                        // sort ready updates by time.
                        buffer.sort_by(|x,y| (x.0).time().cmp(&amp;(y.0).time()));

                        // retire updates in time order.
                        for (time, mut vals) in buffer.drain(..) {
                            let mut session = output.session(&amp;time);
                            for (word, diff) in vals.drain(..) {
                                let entry = counts.entry(word.clone()).or_insert(0i64);
                                *entry += diff;
                                session.give((word, *entry));
                            }
                        }
                    }
                })
<span class="boring">                 .container::&lt;Vec&lt;_&gt;&gt;()
</span><span class="boring">                 .inspect(|x| println!("seen: {:?}", x))
</span><span class="boring">                 .probe_with(&amp;mut probe);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // feed the dataflow with data.
</span><span class="boring">        for round in 0..10 {
</span><span class="boring">            input.send(("round".to_owned(), 1));
</span><span class="boring">            input.advance_to(round + 1);
</span><span class="boring">            while probe.less_than(input.time()) {
</span><span class="boring">                worker.step();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }).unwrap();
</span><span class="boring">}</span></code></pre></pre>
<p>That was probably a lot to see all at once. So let's break down each of the things we did.</p>
<pre><code class="language-rust ignore">.unary_frontier(
    Exchange::new(|x: &amp;(String, i64)| (x.0).len() as u64),
    "WordCount",
    |_capability, operator_info| {
        // coming soon!
    }
)</code></pre>
<p>The very first thing we did was state that we are going to build a new unary dataflow operator. Timely lets you build your own operators just by specifying the logic for them as a closure. So easy! But, we have to explain a few things to the operator.</p>
<p>First, we tell it how it should distribute the data (pairs of strings and differences) between workers. Here we are saying "by the length of the text" which is a deranged way to do it, but we'd need about five more lines to properly write hashing code for the string.</p>
<p>Second, we give a descriptive name so that the operator is recognizable in logging and diagnostic code; you probably don't care at the moment, but you might later on if you wonder what is going on.</p>
<p>Third and finally, we specify a closure. The closure has an argument, which we ignore in the code (it has to do with writing operators that can send output data before they receive any input data) and we will ignore it now. This closure is actually a "closure builder": it is a closure that just returns another closure:</p>
<pre><code class="language-rust ignore">    // allocate operator-local storage.
    let mut queues = HashMap::new();
    let mut counts = HashMap::new();
    let mut buffer = Vec::new();

    move |input, output| {
        // coming soon!
    }</code></pre>
<p>The closure that we end up returning is the <code>|input, output|</code> closure. It describes what the operator would do when presented with a handle to the input and a handle to the output. We've also named two hash maps and a vector we will need, and provided the <code>move</code> keyword to Rust so that it knows that the resulting closure <em>owns</em> these hash maps, rather than <em>borrows</em> them.</p>
<p>Inside the closure, we do two things: (i) read inputs and (ii) update counts and send outputs. Let's do the input reading first:</p>
<pre><code class="language-rust ignore">        // for each input batch, stash it at `time`.
        while let Some((time, data)) = input.next() {
            queues.entry(time.retain())
                  .or_insert(Vec::new())
                  .extend(std::mem::take(data));
        }</code></pre>
<p>The <code>input</code> handle has a <code>next</code> method, and it optionally returns a pair of <code>time</code> and <code>data</code>, representing a timely dataflow timestamp and a hunk of data bearing that timestamp, respectively. Our plan is to iterate through all available input (the <code>next()</code> method doesn't block, it just returns <code>None</code> when it runs out of data), accepting it from the timely dataflow system and moving it into our <code>queue</code> hash map.</p>
<p>Why do we do this? Because this is a streaming system, we could be getting data out of order. Our goal is to update the counts in time order, and to do this we'll need to enqueue what we get until we also get word that the associated <code>time</code> is complete. That happens in the next few hunks of code</p>
<p>First, we extract those times and their data that are ready to go:</p>
<pre><code class="language-rust ignore">        // enable each stashed time if ready.
        for (time, vals) in queues.iter_mut() {
            if !input.frontier().less_equal(time.time()) {
                let vals = std::mem::replace(vals, Vec::new());
                buffer.push((time.clone(), vals));
            }
        }</code></pre>
<p>Here we look through each <code>(time, vals)</code> pair that we've queued up. We then check <code>input.frontier</code>, which is what tells us whether we might expect more times or not. The <code>input.frontier()</code> describes times we may yet see on the input; if it is <code>less_equal</code> to the time, then it is possible there might be more data.</p>
<p>If the time is complete, we extract the data and get ready to act on it. We don't actually act <em>yet</em>, because many times may become available at once, and we want to process them in order too. Before we do that, some housekeeping:</p>
<pre><code class="language-rust ignore">        // drop complete time and allocations.
        queues.retain(|time, vals| vals.len() &gt; 0);

        // sort ready updates by time.
        buffer.sort_by(|x,y| (x.0).time().cmp(&amp;(y.0).time()));</code></pre>
<p>These calls clean up the <code>queues</code> hash map removing keys we are processing, and then sort <code>buffer</code> by time to make sure we process them in order. This first step is surprisingly important: the keys of this hash map are timestamps that can be used to send data, and we need to drop them for timely dataflow to understand that we give up the ability to send data at these times.</p>
<p>Finally, we drain <code>buffer</code> and process updates in time order</p>
<pre><code class="language-rust ignore">        // retire updates in time order.
        for (time, mut vals) in buffer.drain(..) {
            let mut session = output.session(&amp;time);
            for (word, diff) in vals.drain(..) {
                let entry = counts.entry(word.clone()).or_insert(0i64);
                *entry += diff;
                session.give((word, *entry));
            }
        }</code></pre>
<p>Here we process each time in order (we sorted them!). For each time, we create a new output session from <code>output</code> using <code>time</code> More importantly, this actually needs to be the same type as <code>time</code> from before; the system is smart and knows that if you drop all references to a time you cannot create new output sessions. It's a feature, not a bug.</p>
<p>We then proceed through each of the batches we enqueue, and through each of the <code>(word, diff)</code> pairs in each of the batches. I've decided that what we are going to do is update the count and announce the new count, but you could probably imagine doing lots of different things here.</p>
<h2 id="the-finished-product"><a class="header" href="#the-finished-product">The finished product</a></h2>
<p>You can check out the result in <a href="https://github.com/TimelyDataflow/timely-dataflow/blob/master/timely/examples/wordcount.rs"><code>examples/wordcount.rs</code></a>. If you run it as written, you'll see output that looks like:</p>
<pre><code class="language-ignore">    Echidnatron% cargo run --example wordcount
        Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
        Running `target/debug/examples/wordcount`
    seen: ("round", 1)
    seen: ("round", 2)
    seen: ("round", 3)
    seen: ("round", 4)
    seen: ("round", 5)
    seen: ("round", 6)
    seen: ("round", 7)
    seen: ("round", 8)
    seen: ("round", 9)
    seen: ("round", 10)
    Echidnatron%
</code></pre>
<p>We kept sending the same word over and over, so its count went up. Neat. If you'd like to run it with two workers, you just need to put <code>-- -w2</code> at the end of the command, like so:</p>
<pre><code class="language-ignore">    Echidnatron% cargo run --example wordcount -- -w2
        Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
        Running `target/debug/examples/wordcount -w2`
    seen: ("round", 1)
    seen: ("round", 2)
    ...
    seen: ("round", 19)
    seen: ("round", 20)
    Echidnatron%
</code></pre>
<p>Because there are two workers, each inputting <code>"round"</code> repeatedly, we count up to twenty. By the end of this text you should be able to produce more interesting examples, for example reading the contents of directories and divvying up responsibility for the files between the workers.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter_2/chapter_2_4.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapter_3/chapter_3.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter_2/chapter_2_4.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapter_3/chapter_3.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
